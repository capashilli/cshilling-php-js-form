Welcome to my live dev log for the project. Things are going to take a little longer since I'm writing this, but it's valuable to me to get my thoughts down while navigating multiple unfamiliar technologies (having last used Laravel several years ago, and React even further back), and it might be interesting to the evaluator(s).

Necessary startup steps:

Install node, npm, php, and composer if you don't have them
Enable the fileinfo and sqlite php extensions

npm install
php composer.phar install
php artisan migrate
php artisan db:seed

npm run dev
php artisan serve


Environment and base app setup: Like an hour
1. Install latest PHP version from php.net
2. Add it to the PATH
3. Search it to make sure I did it correctly
4. See Composer in a StackOverflow comment and remember that it exists
5. Install Composer
6. Hit the Laravel website. okay good thing I already got Composer
8. Create a local folder and a github repository
8a. Edit the php.ini to enable the fileinfo and sqlite extensions
9. Run the Laravel project generator via Composer
10. See a banner for Inertia, an integration of Laravel and React/Vue/Svelte
11. okay, fine
12. Install Laravel Breeze (= Inertia) using Composer, then run the Breeze install, choosing React as the FE stack
12a. I don't know React well but there's a first time for everything
13. Run the migration to create a SQLite database
14. Setup complete
14a. I sure hope using Inertia for this is okay


"Is it working?": 5 minutes or so
0. Using the Inertia install auto-generates a lot of code, which I'm going to want to strip out a lot of
1. Start the app (npm run dev, php artisan serve)
2. "This is the Vite development server" page. Let's try and get our own frontend home page working first.
3. Oh, it serves to the Laravel app port. Yes, that's working.


"What do I need to remove?": 10 minutes
1. This is a lot of CSS classes they're using on these
2. Oh, there's only one CSS file.
3. What the hell is a @tailwind
3a. It's not in the vendor folder
3b. *searches "react tailwind"*
4. Tailwind seems useful, I'll look at that again later
5. What do I want the app to be? Login and registration is always fine, but a bit samey, and would be basically reusing a lot of the pregen code.
6. I'll do a Pathfinder game character proposal with inputs validated against a database of valid inputs
6a. No, wait. That stuff should absolutely be lists or dropdowns to choose from, not an input box
6b. The assignment is to validate something. I still validate in case of a malformed request, but you can't mess up a dropdown too badly
6c. It's probably okay that only a few things realistically need validation (can't leave your name empty?)
7. I don't need as many pages as the example app has, so I can strip some of the pages (and routes) out
8. I also don't need stuff like the ApplicationLogo component, but I'll keep some others to build off of
9. I'll keep the broad structure in place to hint at syntax but tear out all the interior and rebuild it


Feature scratchpad: 10-15 minutes
1. Greeting copy
2. Character name (max length?)
3. Class, ancestry, and background can all be lists or dropdowns
4. Don't allow a duplicate or empty name
5. Extra: Display all characters currently in the party
6. Extra: UD of the above to go with the CR
7. Extra: Optional versatile heritage / manual input of uncommon/rare options


Creating the Database: A little over an hour
1. What tables do I need in the database?
2. Characters can be a single table with columns for the various attributes
3. Each attribute should be a table, and each option a row
4. There's no need to be relational here--the characters can store their selected options as strings rather than IDs
4a. This saves me some complexity, since I've never designed a database before
5. Okay, sounds good. Now, how do I write the code that makes this happen?
6. Looks like I add a model for each table, then add stuff to the seeder with an array of the rows I want
7. I'll start with the Character model, and I'll edit the existing User model as a base
7a. I don't need to extend Authenticatable and don't need HasApiTokens or Notifiable. I don't really need HasFactory right now, since all data going into the db is being handcoded.
8. Okay, not too bad. The others are just two columns each, so we'll just finish those off
8a. Oh, naming a class Class might be a problem. Let's rename it to CharacterClass. I don't think "Ancestry" will be an issue, but I'll keep it in mind.
9. Anyway, the models are done, and I've gotten a handful of rows written into the DatabaseSeeder.php.
9a. After checking the docs for the correct syntax.
9b. There has to be a way to do this that doesn't make such a mess of the DatabaseSeeder file. Will check later.
10. I can similarly get the migrations written pretty quickly by looking at the existing ones.
11. These migration names look autogenerated. I'll check the docs and see what the generate command is.
11a. Okay, got all my migrations created, now I just fill them in.
11b. Ancestry, background, and class all have the same fields here, but it would not be wise to store all of them in the same table ("character options" or something), since they would quickly diverge if more features were added.
12. Done. (I can do more data entry for character options later on.)


Removing Things I Don't Want: 20 minutes
1. I don't need login, registration, users, auth tokens, or indeed authentication here, so I need to remove those, references to those, and unit tests that check for those.
2. poking around through the other files and folders to see if anything else is relevant to me before I start on the actual functional code
3. Comment out all the routes I'm not using
4. Try out the Artisan `inspire` command (it's described in one of the routes files, console.php)
4a. neat
5. Okay, the app.blade is the container for the entire site. @inertia must be the anchor for the React portion.
6. If I edit the welcome.blade, nothing happens, but editing the Welcome.jsx does have an effect. The welcome.blade might just be leftover from the Laravel install before the inertia one.
6a. I can delete the welcome.blade without complaint from the "compiler", but not the app.blade. Interesting. The app blade also has stuff that isn't in the app.jsx, so it makes sense.
6b. Side note: This live loads *insanely* fast when I save a change. Wow!


Adding Features: Several hours, about 80% puzzling out how to accomplish the function I know I need (e.g. a db query)
1. Where the hell is the bit that submits the form data
2. Okay, so the route points to the php controller, and the controller calls Inertia::render on the React component, providing an array of key-value pairs as the React props.
3. I can't find a straightforward db/api query I can recognize. Let's see if we can request an entire user and somehow get it to the frontend (or console).
4. [a long time of reading code]
5. Achieving a very basic console.log of a fetched user object has actually really paid off for understanding this.
6. Okay, subcomponents within a page can call usePage() to get a representation of the parent page, then props is a property of the result.
7. It really is uncanny how much that console.log made things click. It's like going from a rat in a maze to a plumber in a complicated basement. I'll start adding my own components now.
8. I think I only want one page, actually, but it'll have several subcomponents. Let's start with subcomponents and see what data I need to provide from the parent page. I'll just duplicate the directory structure of the other pages.
9. I don't think listing the characters should be an extra, actually. I'll just plan on that from the start
10. PartyList and AddCharacter subcomponents basically covers it.
11. I can keep the welcome screen, just altered to show our welcome copy, in addition to this page.
12. Interesting syntax on useState. Good to have a dedicated method for this
13. After some time with the docs, I now understand how to use the Eloquent ORM
14. Sidetrack to add a .gitignore and remove node_modules and vendor folders from the repo
15. An error message instead of nothing! Hurrah!
16. Okay, it's not actually using Eloquent as the driver, but I don't want to get sidetracked and the DB facade is perfectly usable as-is. Necessary info from the database is now reaching the frontend, that's the important part
17. I'll grab the react-select library, since you'd want autocomplete if you had the full list of all the backgrounds in PF.
18. Okay, the form is built. Just a text input and three dropdowns, so not too complex, and all the inputs properly update the frontend data structure. Now to just send it to the backend and get the new character into the DB.
19. Manual input of non-common options is too much feature creep, I think.
20. Successfully inserted new characters into the db and displayed on the frontend.


QA/Debugging: 10-15 min
1. Duplicate and empty names are properly rejected, good
2. Rebuilding the db works correctly
3. The select and orderBy operations work correctly; only common options are shown, and they're alphabetized


Aesthetics and Restructuring: 90 minutes
1. Okay, I need styles and copy, and to finally remove all code that isn't relevant to the app
2. [slashing and burning of pregen code]
3. I'll do a little more data entry so there's a good variety of testable cases, it's worth a few minutes to have some fun with it
4. Wow, I'm really used to Sass. I had forgotten you can't use nested rules in normal CSS
5. I'll try and use Tailwind classes for cleaner code; the handful of custom rules can go in the app.css if there's not that many.
6. Yeah, this is more efficient, and it would be a *lot* more efficient if I already knew a good amount of the class names.


Compatibility (i.e. can I install this from the repo and have it work correctly)

1. Write the README
2. Clone the repo from github and follow my own readme
3. It works!